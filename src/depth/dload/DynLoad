### Dynamic Loading

Dynamic compilation and loading [2 points].

We introduce the `use` syntactic form to eScheme and vScheme, which
calls the compiler to compile a specified file, loads the code into a
function in the SVM, and calls the function for its side effects.

To do so, we introduce two new SVM instrutions: `popen` and `dload`.
`popen`, given a register and list of symbols, creates a new process with the
command specified by interpreting those symbols as tokens and opens a pipe
between the new process and the SVM. It then places the file descriptor for
the read end of the pipe in the register.

`dload`, given a destination register and a register containing a file
descriptor, reads from the associated file, passing its contents to the loader.
The resulting VM function is wrapped in a closure and placed in the destination
register.

Both `popen` and `dload` become register-setting primitives in the UFT.

Using these new primitives, we define `use` as a function in the initial basis.

```
(define use (filename)
  (let* ([cmd (cons 'uft (cons 'es-vo (cons filename '())))]
         [fd (popen cmd)]
         [module (dload fd)])
         (module)))
```

That is, popen is used to call the compiler, open a pipe, and get the file
descriptor, dload is used to produce a VM function from the file, and the
function, `module`, is called to produce its side effects.

This is fine if we are okay with `use` used as any other expression would, but
Î¼Scheme only allows it as a definition form. Thus, we have made `use` a
reserved keyword, preventing it from being referenced as a global. Instead,
we create an addition syntactic form in vScheme (Use Name), which is desugared
to a call to function `use` during disambiguation.

 In another life, we might want to change `dload` and `pipeopen` as 
 different primitives, and get rid of the definition of `use` in scheme.

The examples assumes you have `uft` as an alias for the UFT binary, and you are
currently located in `src/huft` directory. 
You can change the initial basis function to acoomodate other commands 
(like `uft`, or `./bin/uft`).

In ./test/doad/ directory. There are 3 examples. 

`dload.scm` loads `loadme.scm`, and it should change global 
variable `message` from 'load-failure to 'load-success.

`good.scm` loads `goodload.scm` which contains predefined functions 
like `filter` and `map`. `good.scm` then runs funcitons that are defined 
in the `goodload.scm` file.


`scheme105.scm` loads `predef.scm`, which should load all the predefined 
functions and run 105 homework 3 code. The `predef.scm` is a shortened version 
since our dload seems incapable of loading that many new global variables.

